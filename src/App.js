import * as THREE from 'three'
import React, { Suspense, useRef, useState, forwardRef, useImperativeHandle } from 'react'
import { Canvas, useFrame, useThree } from '@react-three/fiber'
import { Environment, useGLTF, ContactShadows, OrbitControls, Html, useHelper } from '@react-three/drei'
// import { Environment, useGLTF, ContactShadows, OrbitControls, Html, useHelper } from '@react-three/drei'
import gsap from 'gsap'
import HeroPage from './HeroPage'


/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/
export function Model(props) {
  const { nodes, materials } = useGLTF('/l8niteoffice.glb')
  const coneRef = useRef() // Reference for the floating 
  useFrame((state) => {
    const t = state.clock.getElapsedTime()
    if (coneRef.current) {
      coneRef.current.position.y = THREE.MathUtils.lerp(coneRef.current.position.y, 1.911 + Math.sin(t*4) * 0.1, 1.1) // Bobbing effect
    }
  })

  return (
    <group {...props} dispose={null}>
      {/* mail  */}
    <IconLink url="mailto:taha.sarfraz11@gmail.com">
      <group rotation={[-Math.PI / 2, 0, 0]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Object_2.geometry}
          material={materials['Material.001']}
          position={[-0.957, 0.763, 1.084]}
          rotation={[0, 0, -3.121]}
          scale={[0.063, 0.394, 0.062]}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Object_3.geometry}
          material={materials['Material.002']}
          position={[-0.957, 0.751, 1.084]}
          rotation={[0, 0, -3.121]}
          scale={[0.063, 0.4, 0.062]}
        />
      </group>
    </IconLink>

    {/* github */}
    <IconLink url="https://github.com/GBG7">
      <group position={[0, -0.004, 0]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[455.882, 10, -142.771]} rotation={[-Math.PI / 2, 0, 0]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.GitHubLogo_GitHubLogo_0.geometry}
              material={materials['WindowsLogo2.001']}
              position={[-5.51, -0.577, 1.418]}
              rotation={[1.564, 0, 0]}
              scale={[0.281, 0.281, 0.635]}
            />
          </group>
        </group>
      </group>
    </IconLink>
    {/* instagram */}
    <IconLink url="https://www.instagram.com/tahasafs">
      <group position={[0, 0.069, -2.43]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Objeto_1_Tinta_0.geometry}
            material={materials.Tinta}
            position={[-106.458, 175.654, 155.42]}
            scale={[0.287, 0.287, 1]}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Objeto_5_Tinta_0.geometry}
            material={materials.Tinta}
            position={[-106.458, 175.654, 155.42]}
            scale={[0.287, 0.287, 1]}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Objeto_6_Tinta_0.geometry}
            material={materials.Tinta}
            position={[-106.458, 175.654, 155.42]}
            scale={[0.287, 0.287, 1]}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes['Objeto_3_Tinta_(3)_0'].geometry}
            material={materials.Tinta_3}
            position={[-106.458, 175.654, 155.42]}
            scale={[0.287, 0.287, 1]}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes['Objeto_4_Tinta_(3)_0'].geometry}
            material={materials.Tinta_3}
            position={[-106.458, 175.654, 155.42]}
            scale={[0.287, 0.287, 1]}
          />
        </group>
      </group>
      </IconLink>

      {/* loinkedon */}
    <IconLink url="https://www.linkedin.com/in/taha-s-54b429274/">
      <group position={[-0.069, 0.112, 0]} rotation={[-Math.PI / 2, 0, 0]}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <group position={[-647.68, 42.351, 149.429]} scale={100}>
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.LinkedinLogo2_LinkedinLogo2_0.geometry}
              material={materials.PatreonLogo2_2}
              position={[5.574, 1.806, -2.234]}
              rotation={[-Math.PI, 0.059, -Math.PI]}
              scale={[0.321, 0.318, 0.998]}
            />
            <mesh
              castShadow
              receiveShadow
              geometry={nodes.LinkedinLogo2_LinkedinLogo2_2_0.geometry}
              material={materials.LinkedinLogo2_2}
              position={[5.574, 1.806, -2.234]}
              rotation={[-Math.PI, 0.059, -Math.PI]}
              scale={[0.321, 0.318, 0.998]}
            />
          </group>
        </group>
      </group>
    </IconLink>
      <mesh
        ref={coneRef} // Attach ref for animation
        castShadow
        receiveShadow
        geometry={nodes.Cone.geometry}
        material={materials['Material.003']}
        position={[1.647, 1.911, 1.132]}
        rotation={[3.03, 0, 0]}
        scale={[0.174, 0.151, 0.176]}
      />
      <group scale={0.01}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Boxes_BOXES_Mat_0.geometry}
          material={materials.BOXES_Mat}
          position={[9.951, 142.012, 2.406]}
          rotation={[-Math.PI / 2, 0, 0]}
          scale={100}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Room_ROOM_Mat_0.geometry}
          material={materials.ROOM_Mat}
          position={[-19.137, 168.453, -33.842]}
          rotation={[-Math.PI / 2, 0, 0]}
          scale={100}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Window_WINDOW_Mat_0.geometry}
          material={materials.WINDOW_Mat}
          position={[-19.521, 166.582, -28.049]}
          rotation={[-Math.PI / 2, 0, 0]}
          scale={100}
        />
      </group>
    </group>
  )
}

// function HoverableCube({ position, rotation, scale, moveTo, setLastCameraPosition, controlsRef }) {
//   const [hovered, setHovered] = useState(false)
//   const { camera, controls } = useThree()

//   const handleClick = () => {
//     console.log('cube click. Moving to:', moveTo)

//     // for reset button
//     setLastCameraPosition([camera.position.x, camera.position.y, camera.position.z])
//     debugger
//     // camera transition to x,y,z
//     const sph = new THREE.Spherical()
//     const target = controlsRef.current.target
//     let tmp = {
//       distance: controlsRef.current.getDistance(),
//       phi: controlsRef.current.getPolarAngle(),
//       theta: controlsRef.current.getAzimuthalAngle()
//     }

//     // gsap.to(tmp, {
//     //   theta: Math.PI * 0.5,
//     //   duration: 1.5,
//     //   ease: 'power2.out',
//     //   onStart: () => {
//     //     controlsRef.current.enabled = false
//     //   },
//     //   onComplete: () => {
//     //     controlsRef.current.enabled = true
//     //     controlsRef.current.update()
//     //   },
//     //   onUpdate: () => {
//     //     sph.set(tmp.distance, tmp.phi, tmp.theta)
//     //     camera.position.setFromSpherical(sph).add(target)
//     //     camera.lookAt(target)
//     //   }
//     // })

//     gsap.to(camera.position, {
//       x: moveTo[0],
//       y: moveTo[1],
//       z: moveTo[2],
//       duration: 1.5,
//       ease: 'power2.out',
//     })
//     // const target = new THREE.Vector3(position[0], position[1], position[2]);
//     // // let sph = new THREE.Spherical(controlsRef.current.getDistance(),
//     // controlsRef.current.getPolarAngle(), controlsRef.current.getAzimuthalAngle());
//     // camera.position.setFromSpherical( sph ).add( target )
//     // camera.lookAt( target )
//     // Where i'm having issues with. Camera won't look at the position.
//     // camera.lookAt(position[0], position[1], position[2])
//     // controls.target = controls.target || new Vector3();
//     // controls.target.set(position[0], position[1], position[2]);
//   }

//   return (
//     <group>
//       {/* Main Cube */}
//       <mesh
//         castShadow
//         receiveShadow
//         position={position}
//         rotation={rotation}
//         scale={scale}
//         onPointerOver={() => setHovered(true)}
//         onPointerOut={() => setHovered(false)}
//         onClick={handleClick} // camera click move
//       >
//         <boxGeometry args={[1, 1, 1]} />
//         <meshStandardMaterial color="blue" transparent={false} opacity={0.01} />
//       </mesh>

//       {/* White Outline on Hover */}
//       {hovered && (
//         <lineSegments position={position} rotation={rotation} scale={scale}>
//           <edgesGeometry attach="geometry" args={[new THREE.BoxGeometry(1, 1, 1)]} />
//           <lineBasicMaterial attach="material" color="white" linewidth={1} />
//         </lineSegments>
//       )}
//     </group>
//   )
// }

const DisplayHoverableCube = forwardRef(function HoverableCube(
  { position, rotation, scale, moveTo, setLastCameraPosition, content: ContentComponent, controlsRef }, // <-- Accepts a content prop
  ref
) {
  const [hovered, setHovered] = useState(false)
  const [clickable, setClickable] = useState(true)
  const [showHtml, setShowHtml] = useState(false)
  const { camera, controls } = useThree()

  // Expose a .reset() method to reset state
  useImperativeHandle(ref, () => ({
    reset() {
      setShowHtml(false) // Hide the HTML content
      setClickable(true) // Make the cube clickable again
    }
  }))

const handleClick = () => {
  if (!clickable) return;
  setLastCameraPosition([ camera.position.x, camera.position.y, camera.position.z ]);

  // build your new “look at” target
  const [tx, ty, tz] = moveTo;
  // tween camera.position
  gsap.to(camera.position, {
    x: tx, y: ty, z: tz,
    duration: 1.5,
    ease: 'power2.out'
  });
  // tween OrbitControls.target
  gsap.to(controlsRef.current.target, {
    x: tx, y: ty, z: tz+0.1,
    duration: 1.5,
    ease: 'power2.out',
    onUpdate: () => {
      // let controls know target moved
      controlsRef.current.update();
    },
    onComplete: () => {
      setShowHtml(true);
      setClickable(false);
    }
  });
}




  return (
    <group>
      <mesh
        castShadow
        receiveShadow
        position={position}
        rotation={rotation}
        scale={scale}
        onPointerOver={() => clickable && setHovered(true)}
        onPointerOut={() => clickable && setHovered(false)}
        onClick={handleClick}
        {...(!clickable && { pointerEvents: 'none' })}>
        <boxGeometry args={[1, 1, 1]} />
        <meshStandardMaterial color="black" transparent={true} opacity={0.01} />

        {showHtml && (
        <Html
          className="content"
          transform={false}
          position={[0.5, -0.6, -0.5]}
          rotation={[1, 0, 3.13]}
          distanceFactor={3}
          occlude
          style={{ pointerEvents: 'auto' }}
        >
          <div
            className="wrapper"
            style={{
              width: 500,
              height: 500,
              background: 'white',
              borderRadius: 10,
              overflow: 'hidden',
            }}
            onPointerDown={(e) => e.stopPropagation()}
          >
            {ContentComponent ? (
              <ContentComponent /> // Render passed React component
            ) : (
              <iframe
                src="/lainsite/index.html" // Fallback iframe from /public
                width="100%"
                height="100%"
                title="Embedded HTML"
                style={{ border: 'none' }}
              />
            )}
          </div>
        </Html>
      )}

      </mesh>

      {hovered && clickable && (
        <>
          {/* Original thin line */}
          <lineSegments position={position} rotation={rotation} scale={scale}>
            <edgesGeometry args={[new THREE.BoxGeometry(1, 1, 1)]} />
            <lineBasicMaterial color="white" />
          </lineSegments>

          {/* Slightly offset duplicates to create thickness */}
          <lineSegments position={position} rotation={rotation} scale={scale.map(s => s * 1.02)}>
            <edgesGeometry args={[new THREE.BoxGeometry(1, 1, 1)]} />
            <lineBasicMaterial color="white" />
          </lineSegments>

          <lineSegments position={position} rotation={rotation} scale={scale.map(s => s * 1.04)}>
            <edgesGeometry args={[new THREE.BoxGeometry(1, 1, 1)]} />
            <lineBasicMaterial color="white" />
          </lineSegments>

          <lineSegments position={position} rotation={rotation} scale={scale.map(s => s * 1.06)}>
            <edgesGeometry args={[new THREE.BoxGeometry(1, 1, 1)]} />
            <lineBasicMaterial color="white" />
          </lineSegments>
          
        </>
      )}

    </group>
  )
})


/**
 * IconLink is a wrapper that makes its children clickable.
 * When hovered, it displays a white BoxHelper outline.
 * On click, it opens the provided URL in a new browser tab.
 */

function IconLink({ children, url }) {
  const ref = useRef()
  const [hovered, setHovered] = useState(false)
  useHelper(hovered ? ref : null, THREE.BoxHelper, 'white') // White outline on hover

  const handleClick = (e) => {
    e.stopPropagation()
    window.open(url, '_blank') // Open URL in new tab
  }

  return (
    <group
      ref={ref}
      onClick={handleClick}
      onPointerOver={(e) => {
        e.stopPropagation()
        setHovered(true)
      }}
      onPointerOut={(e) => {
        e.stopPropagation()
        setHovered(false)
      }}>
      {children}
    </group>
  )
}


function ResetCameraButton({ lastCameraPosition, cubeRefs }) {
  const { camera } = useThree()
  const handleReset = () => {
    if (!lastCameraPosition) return
    console.log('Resetting Camera to:', lastCameraPosition)

    gsap.to(camera.position, {
      x: lastCameraPosition[0],
      y: lastCameraPosition[1],
      z: lastCameraPosition[2],
      duration: 1.5,
      ease: 'power2.out',
      onComplete: () => {
        // Reset all cubes in the array
        cubeRefs?.forEach((ref) => ref.current?.reset())
      }
    })
  }

  return (
    <Html position={[0, 0, 0]} style={{ position: 'absolute', bottom: '270px', left: '570px', zIndex: 1000 }}>
      <button
        onClick={handleReset}
        style={{
          padding: '5px 10px',
          background: 'rgba(0,0,0,0.7)',
          color: 'white',
          border: '1px solid white',
          borderRadius: '8px',
          cursor: 'pointer',
          fontSize: '15px'
        }}>
        ⏎
      </button>
    </Html>
  )
}




useGLTF.preload('/l8niteoffice.glb')
export default function App() {
  const [lastCameraPosition, setLastCameraPosition] = useState(null)
  const heroPageCubeRef = useRef()
  const orbitRef = useRef()
  // const { camera } = useThree()

  // Define reset handler here so it can be used in JSX below
  const handleReset = () => {
    if (!lastCameraPosition) return
    // pull the camera off of the controls
    const controls = orbitRef.current
    const camera = controls.object
    console.log('Resetting Camera to:', lastCameraPosition)

    gsap.to(camera.position, {
      x: lastCameraPosition[0],
      y: lastCameraPosition[1],
      z: lastCameraPosition[2],
      duration: 1.5,
      ease: 'power2.out',
      onComplete: () => {
        heroPageCubeRef.current?.reset()
      }
    })
  }

  return (
    <>
      <Canvas camera={{ position: [-8, 4, -5], fov: 45 }}>
        <pointLight position={[10, 10, 10]} intensity={1.5} />
        <Suspense fallback={null}>
          <group rotation={[0, Math.PI, 0]} position={[0, -2, 0]} scale={[1.5, 1.5, 1.5]}>
            <Model />

            <DisplayHoverableCube
              ref={heroPageCubeRef}
              position={[1.6, 1.3, 1]}
              rotation={[Math.PI / 2, 0, -0.391]}
              scale={[0.4, 0.1, 0.4]}
              moveTo={[-2, 0.1, -0.8]}
              setLastCameraPosition={setLastCameraPosition}
              controlsRef={orbitRef}
            />
          </group>
          <Environment preset="city" />
        </Suspense>
        <ContactShadows position={[0, -4.5, 0]} scale={20} blur={2} far={4.5} />
        <OrbitControls
          ref={orbitRef}
          makeDefault
          enablePan={false}
          enableZoom={true}
          minPolarAngle={Math.PI / 2.2}
          maxPolarAngle={Math.PI / 2.2}
        />
      </Canvas>

      {/* This is now a DOM element, outside Canvas */}
      <div
        style={{
          position: 'fixed',
          bottom: '20px',
          right: '20px',
          zIndex: 1000
        }}
      >
        <button
          onClick={handleReset}
          style={{
            padding: '5px 10px',
            background: 'rgba(0,0,0,0.7)',
            color: 'white',
            border: '1px solid white',
            borderRadius: '8px',
            cursor: 'pointer',
            fontSize: '15px'
          }}
        >
          ⏎
        </button>
      </div>
    </>
  )
}

